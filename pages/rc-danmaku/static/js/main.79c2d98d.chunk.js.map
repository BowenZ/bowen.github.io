{"version":3,"sources":["App.tsx","index.tsx"],"names":["textArr","Array","from","getRandomText","length","Math","floor","random","fill","map","getRandomIndex","join","TestDanmaku","danmakuInsRef","useRef","useState","showColor","setShowColor","colorRef","isPaused","setIsPaused","useEffect","danmakuIns","Danmaku","rowHeight","speed","opacity","maxRow","undefined","minGapWidth","current","document","querySelector","value","pause","resume","Wrapper","className","type","min","max","step","onChange","e","target","Number","checked","defaultValue","style","visibility","onClick","emit","color","$input","trim","focus","TestNode","push","pushAll","p","destroy","alert","styled","div","ReactDOM","render","StrictMode","App","getElementById"],"mappings":"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","file":"static/js/main.79c2d98d.chunk.js","sourcesContent":["import React, { useEffect, useRef, useState } from 'react';\nimport styled from 'styled-components';\n// import Danmaku from '../../src/index';\nimport Danmaku from 'rc-danmaku';\n\nconst textArr = Array.from(\n  '通过对平面中竖直和水平方向的分析我们将宽泛的弹幕重叠问题收敛为轨道中相邻弹幕两两之间的追及问题最终获得了将候选弹幕挂载到合适轨道中的调度策略'\n);\n\nfunction getRandomIndex(length: number): number {\n  return Math.floor(Math.random() * length);\n}\n\nfunction getRandomText(): string {\n  const length = Math.floor(Math.random() * 19) + 1;\n  return Array(length)\n    .fill(null)\n    .map(() => {\n      return textArr[getRandomIndex(textArr.length)];\n    })\n    .join('');\n}\n\nconst TestDanmaku: React.FC = () => {\n  const danmakuInsRef = useRef<Danmaku | null>(null);\n  const [showColor, setShowColor] = useState(false);\n  const colorRef = useRef('');\n  const [isPaused, setIsPaused] = useState(false);\n\n  useEffect(() => {\n    // 第一个参数是弹幕容器，可以传string类型的选择器，或者直接传dom元素\n    // 第二个object类型的参数是可选参数，包含弹幕配置，里边的所有项均不是必填项\n    const danmakuIns = new Danmaku('.danmaku-wrapper', {\n      rowHeight: 60, // 弹幕轨道高度，默认40（单位px）\n      speed: 120, // 弹幕速度，默认100（单位px/s）\n      opacity: 1, // 弹幕透明度，默认为1，范围 0-1\n      maxRow: undefined, // 弹幕最大轨道数，会根据容器高度自动计算，也可以手动赋值\n      minGapWidth: 30, //弹幕之前的最小间隔宽度，默认值20（单位px）\n    });\n    danmakuInsRef.current = danmakuIns;\n  }, []);\n\n  useEffect(() => {\n    if (showColor) {\n      colorRef.current = (document.querySelector(\n        '.color-piker'\n      ) as HTMLInputElement).value;\n    }\n  }, [showColor]);\n\n  useEffect(() => {\n    if (danmakuInsRef.current) {\n      if (isPaused) {\n        danmakuInsRef.current.pause();\n      } else {\n        danmakuInsRef.current.resume();\n      }\n    }\n  }, [isPaused]);\n  return (\n    <Wrapper className=\"test-danmaku\">\n      <div className=\"danmaku-wrapper\" />\n      <div>\n        <span>透明度</span>\n        <input\n          type=\"range\"\n          min=\"0\"\n          max=\"1\"\n          step=\"0.1\"\n          onChange={(e): void => {\n            if (danmakuInsRef.current) {\n              const { value } = e.target;\n              danmakuInsRef.current.opacity = Number(value);\n            }\n          }}\n        />\n      </div>\n      <div>\n        <span>彩色弹幕：</span>\n        <input\n          type=\"checkbox\"\n          onChange={(e): void => {\n            const { checked } = e.target;\n            setShowColor(checked);\n          }}\n        />\n        &nbsp;&nbsp;&nbsp;\n        <input\n          className=\"color-piker\"\n          type=\"color\"\n          defaultValue=\"#ff0000\"\n          style={{\n            visibility: showColor ? 'visible' : 'hidden',\n          }}\n          onChange={(e): void => {\n            const { value } = e.target;\n            colorRef.current = value;\n          }}\n        />\n      </div>\n      <button\n        type=\"button\"\n        onClick={(): void => {\n          if (danmakuInsRef.current) {\n            danmakuInsRef.current.emit(getRandomText(), {\n              color: showColor ? colorRef.current : undefined,\n            });\n          }\n        }}\n      >\n        发送随机文本（过多会重叠）\n      </button>\n      <div>\n        <span>输入文本：</span>\n        <input type=\"text\" className=\"danmaku-text-input\" />\n        <button\n          type=\"button\"\n          onClick={(): void => {\n            if (danmakuInsRef.current) {\n              const $input = document.querySelector(\n                '.danmaku-text-input'\n              ) as HTMLInputElement;\n              if ($input.value && $input.value.trim()) {\n                danmakuInsRef.current.emit($input.value, {\n                  color: showColor ? colorRef.current : undefined,\n                });\n              }\n\n              $input.value = '';\n              $input.focus();\n            }\n          }}\n        >\n          发送\n        </button>\n      </div>\n      <button\n        type=\"button\"\n        onClick={(): void => {\n          if (danmakuInsRef.current) {\n            danmakuInsRef.current.emit(<TestNode>react node</TestNode>);\n          }\n        }}\n      >\n        发送react节点\n      </button>\n      <button\n        type=\"button\"\n        onClick={(): void => {\n          if (danmakuInsRef.current) {\n            danmakuInsRef.current.push(getRandomText(), {\n              color: showColor ? colorRef.current : undefined,\n            });\n          }\n        }}\n      >\n        推送随机文字到发送队列（过多不会重叠，会延迟发送）\n      </button>\n      <button\n        type=\"button\"\n        onClick={(): void => {\n          if (danmakuInsRef.current) {\n            danmakuInsRef.current.push(<TestNode>react node</TestNode>);\n          }\n        }}\n      >\n        推送React节点到发送队列（过多不会重叠，会延迟发送）\n      </button>\n      <button\n        type=\"button\"\n        onClick={(): void => {\n          if (danmakuInsRef.current) {\n            danmakuInsRef.current.pushAll(\n              Array(20)\n                .fill(null)\n                .map(() => getRandomText()),\n              {\n                color: showColor ? colorRef.current : undefined,\n              }\n            );\n          }\n        }}\n      >\n        随机推送20条文字弹幕\n      </button>\n      <button\n        type=\"button\"\n        onClick={(): void => {\n          if (danmakuInsRef.current) {\n            danmakuInsRef.current.pushAll(\n              Array(20)\n                .fill(null)\n                .map(() => <TestNode>react node</TestNode>)\n            );\n          }\n        }}\n      >\n        随机推送20条React节点\n      </button>\n      <div>\n        {isPaused ? (\n          <span style={{ color: 'red' }}>暂停中</span>\n        ) : (\n          <span style={{ color: 'green' }}>运行中</span>\n        )}\n      </div>\n      <div>\n        <button\n          type=\"button\"\n          onClick={(): void => {\n            setIsPaused((p) => !p);\n          }}\n        >\n          {isPaused ? '继续' : '暂停'}\n        </button>\n      </div>\n      <button\n        type=\"button\"\n        onClick={(): void => {\n          if (danmakuInsRef.current) {\n            danmakuInsRef.current.destroy();\n            alert('组件已经被销毁，任何操作将会无相应，重新刷新页面再测吧');\n          }\n        }}\n      >\n        销毁（销毁后无法再发送弹幕）\n      </button>\n    </Wrapper>\n  );\n};\n\nexport default TestDanmaku;\n\nconst Wrapper = styled.div`\n  display: flex;\n  flex-direction: column;\n  justify-content: center;\n  align-items: center;\n  height: 100vh;\n  height: calc(100vh - 45px);\n  input[type='text'] {\n    padding: 0.2em;\n    width: 150px;\n    max-width: 150px;\n  }\n  button {\n    outline: none;\n    appearance: none;\n    padding: 0.2em 1.45em;\n    margin: 0.1em;\n    border: 0.15em solid #cccccc;\n    color: #000000;\n    background-color: #cccccc;\n    &:hover {\n      border-color: #7a7a7a;\n    }\n    &:active {\n      background-color: #999999;\n    }\n  }\n  .danmaku-wrapper {\n    width: 90%;\n    height: 60vw;\n    max-height: 500px;\n    background-color: #000;\n  }\n`;\n\nconst TestNode = styled.div`\n  width: 100px;\n  height: 30px;\n  background: linear-gradient(90deg, pink, red);\n  border-radius: 20px;\n  color: #fff;\n  line-height: 30px;\n  text-align: center;\n`;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport App from './App';\n// import QuickStart from './QuickStart';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n    {/* <QuickStart></QuickStart> */}\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n"],"sourceRoot":""}