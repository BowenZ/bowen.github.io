{"version":3,"sources":["../../src/Bullet.tsx","../../src/utils.ts","../../src/Danmaku.tsx","App.tsx","index.tsx"],"names":["BulletStatus","Bullet","node","options","status","PENDING","element","speed","targetContainer","trackIndex","rowHeight","onTotalOut","isTotalOut","rightDistance","totalOutTimer","this","div","document","createElement","className","setAttribute","style","opacity","String","reactNode","textShadow","color","fontSize","ReactDOM","render","appendChild","width","getBoundingClientRect","left","top","minGapWidth","paddingRight","addEventListener","console","log","destroy","FINISHED","onDestroy","bulletLeft","notOutWidth","offsetWidth","totalOutTime","setTimeout","clearTimeout","transition","scrollWidth","toFixed","transform","RUNNING","startTotalOutTimer","containerLeft","containeWidth","PAUSED","clearTotalOutTimer","unmountComponentAtNode","remove","valueIsNotNulish","value","undefined","Danmaku","ele","container","height","trackCount","allPaused","isDestroyed","trackList","queue","isRunningWhenPageHide","visibilityChangeEventHandle","visibilityState","pause","resume","optionsParamsCheck","querySelector","Error","DEFAULT_ROW_HEIGHT","DEFAULT_SPEED","DEFAULT_OPACITY","DEFAULT_GAP_WIDTH","classList","add","containerClassName","position","overflow","Math","floor","maxRow","min","Array","fill","map","length","result","minCount","forEach","list","index","filter","bullet","getTrackIndex","bulletItem","popBulletToFreeTrack","targetTrackIndex","item","isFinished","push","run","some","bullets","hasFreeTrack","shift","emit","nodeArr","removeEventListener","numberIsGreaterThanZero","number","textArr","from","getRandomText","random","getRandomIndex","join","TestDanmaku","danmakuInsRef","useRef","useState","showColor","setShowColor","colorRef","isPaused","setIsPaused","useEffect","danmakuIns","current","Wrapper","type","max","step","onChange","e","target","Number","checked","defaultValue","visibility","onClick","$input","trim","focus","TestNode","pushAll","p","alert","styled","StrictMode","App","getElementById"],"mappings":"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","file":"static/js/main.cedee1c4.chunk.js","sourcesContent":["import React from 'react';\nimport ReactDOM from 'react-dom';\n\nenum BulletStatus {\n  // 等待中\n  PENDING = 'pending',\n  // 运行中\n  RUNNING = 'running',\n  // 暂停中\n  PAUSED = 'paused',\n  // 已完成\n  FINISHED = 'finished',\n}\n\nclass Bullet {\n  // 当前状态\n  status: BulletStatus = BulletStatus.PENDING;\n\n  // 弹幕DOM元素\n  element: HTMLElement;\n\n  // 速度\n  speed: number;\n\n  // 目标挂载容器\n  targetContainer: HTMLElement;\n\n  // 目标轨道\n  trackIndex: number;\n\n  // 弹幕行高\n  rowHeight: number;\n\n  // 弹幕完全显示的回调\n  onTotalOut: ((trackIndex: number) => void) | undefined;\n\n  // 是否全部出现\n  public isTotalOut = false;\n\n  // 暂停时距离右边的距离\n  private rightDistance = 0;\n\n  // 弹幕全部出现的计时器\n  private totalOutTimer = 0;\n\n  constructor(\n    node: React.ReactElement | string,\n    options: {\n      color?: string;\n      speed: number;\n      opacity: number;\n      targetContainer: HTMLElement;\n      trackIndex: number;\n      rowHeight: number;\n      minGapWidth?: number;\n      onTotalOut?: (trackIndex: number) => void;\n      onDestroy(trackIndex: number): void;\n    }\n  ) {\n    this.speed = options.speed;\n    this.targetContainer = options.targetContainer;\n    this.trackIndex = options.trackIndex;\n    this.rowHeight = options.rowHeight;\n    this.onTotalOut = options.onTotalOut;\n    const div = document.createElement('div');\n    div.className = 'bullet-item';\n    div.setAttribute(\n      'style',\n      `position: absolute;\n       line-height: 1.125;\n       user-select: none;\n       white-space: pre;\n       perspective: 500px;\n       will-change: transform;\n       pointer-events: none;`\n    );\n    div.style.opacity = String(options.opacity);\n\n    const reactNode =\n      typeof node === 'string' ? (\n        <span\n          className=\"bullet-item-text\"\n          style={{\n            textShadow:\n              '#000 1px 0px 1px, #000 0px 1px 1px, #000 0px -1px 1px,#000 -1px 0px 1px',\n            color: options.color || '#fff',\n            fontSize: '25px',\n          }}\n        >\n          {node}\n        </span>\n      ) : (\n        node\n      );\n\n    ReactDOM.render(reactNode, div);\n\n    this.element = div;\n\n    options.targetContainer.appendChild(this.element);\n\n    const { width } = this.targetContainer.getBoundingClientRect();\n    div.style.left = `${width}px`;\n    div.style.top = `${this.trackIndex * this.rowHeight}px`;\n    if (options.minGapWidth && options.minGapWidth > 0) {\n      div.style.paddingRight = `${options.minGapWidth}px`;\n    }\n\n    this.element.addEventListener('transitionend', () => {\n      console.log('====transition end====');\n      this.destroy();\n      this.status = BulletStatus.FINISHED;\n      this.isTotalOut = false;\n      options.onDestroy(options.trackIndex);\n    });\n  }\n\n  // 根据弹幕当前位置计算出弹幕完全显示需要的时间，并在改时间后将弹幕状态设置为完全可见状态\n  private startTotalOutTimer(): void {\n    if (this.totalOutTimer) {\n      return;\n    }\n    const { left, width } = this.targetContainer.getBoundingClientRect();\n    const { left: bulletLeft } = this.element.getBoundingClientRect();\n    const notOutWidth = this.element.offsetWidth - (left + width - bulletLeft);\n\n    if (notOutWidth <= 0) {\n      return;\n    }\n\n    // 该条弹幕完全展示出所需的时间\n    const totalOutTime = notOutWidth / this.speed;\n\n    this.totalOutTimer = setTimeout(() => {\n      console.log('====set is total out====');\n      this.isTotalOut = true;\n      this.totalOutTimer = 0;\n      if (this.onTotalOut) {\n        this.onTotalOut(this.trackIndex);\n      }\n    }, totalOutTime * 1000);\n  }\n\n  // 清楚弹幕完全显示状态的计时器\n  private clearTotalOutTimer(): void {\n    if (this.totalOutTimer) {\n      clearTimeout(this.totalOutTimer);\n      this.totalOutTimer = 0;\n    }\n  }\n\n  // 弹幕运行\n  public run(): void {\n    const { width } = this.targetContainer.getBoundingClientRect();\n    this.element.style.transition = `transform ${(\n      (width + this.element.scrollWidth - this.rightDistance) /\n      this.speed\n    ).toFixed(2)}s linear`;\n    this.element.style.transform = `translate3d(-${\n      width + this.element.scrollWidth\n    }px, 0, 0)`;\n    this.status = BulletStatus.RUNNING;\n    this.startTotalOutTimer();\n  }\n\n  // 弹幕暂停\n  public pause(): void {\n    const {\n      left: containerLeft,\n      width: containeWidth,\n    } = this.targetContainer.getBoundingClientRect();\n    const { left: bulletLeft } = this.element.getBoundingClientRect();\n    this.rightDistance = containeWidth - (bulletLeft - containerLeft);\n    this.element.style.transform = `translate3d(-${this.rightDistance}px, 0, 0)`;\n    this.element.style.transition = 'transform 0s linear 0s';\n    this.status = BulletStatus.PAUSED;\n    this.clearTotalOutTimer();\n  }\n\n  // 销毁弹幕\n  public destroy(): void {\n    if (this.totalOutTimer) {\n      clearTimeout(this.totalOutTimer);\n    }\n    ReactDOM.unmountComponentAtNode(this.element);\n    this.element.remove();\n  }\n\n  public get isRunning(): boolean {\n    return this.status === BulletStatus.RUNNING;\n  }\n\n  public get isFinished(): boolean {\n    return this.status === BulletStatus.FINISHED;\n  }\n}\n\nexport default Bullet;\n","export const valueIsNotNulish = (value: unknown): boolean => {\n  return value !== undefined && value !== null;\n};\n\nexport default {\n  valueIsNotNulish,\n};\n","import React from 'react';\nimport Bullet from './Bullet';\nimport { valueIsNotNulish } from './utils';\n\ntype BulletNodeType = React.ReactElement | string;\n\ntype OptionsType = {\n  // 弹幕轨道高度\n  rowHeight?: number;\n  // 弹幕速度\n  speed?: number;\n  // 弹幕初始透明度\n  opacity?: number;\n  // 弹幕最大轨道数\n  maxRow?: number;\n  // 弹幕之前的最小间隔宽度\n  minGapWidth?: number;\n};\n\ntype EmitOptionsType = {\n  color?: string;\n};\n\nclass Danmaku {\n  static DEFAULT_ROW_HEIGHT = 40;\n\n  static DEFAULT_SPEED = 100;\n\n  static DEFAULT_OPACITY = 1;\n\n  static DEFAULT_GAP_WIDTH = 20;\n\n  // 弹幕容器\n  private container: HTMLElement | null = null;\n\n  // 容器宽度\n  width = 0;\n\n  // 容器高度\n  height = 0;\n\n  // 弹幕轨道高度\n  rowHeight = 40;\n\n  // 弹幕轨道数量\n  trackCount = 0;\n\n  // 弹幕速度\n  speed = 100;\n\n  // 弹幕透明度 0-1\n  opacity = 1;\n\n  // 弹幕之前的最小间隔宽度\n  minGapWidth = 0;\n\n  // 是否处于暂停中\n  allPaused = false;\n\n  // 是否已被销毁\n  isDestroyed = false;\n\n  // 当前展示的弹幕数组\n  private trackList: Array<Array<Bullet>> = [];\n\n  // 待发送的弹幕队列\n  private queue: Array<{\n    node: BulletNodeType;\n    options?: EmitOptionsType;\n  }> = [];\n\n  private isRunningWhenPageHide = true;\n\n  static containerClassName = 'danmaku-container';\n\n  constructor(ele: string | HTMLElement, options: OptionsType = {}) {\n    Danmaku.optionsParamsCheck();\n    if (typeof ele === 'string') {\n      this.container = document.querySelector(ele);\n      if (!this.container) {\n        throw new Error('container not found');\n      }\n    } else {\n      this.container = ele;\n    }\n    this.rowHeight = options.rowHeight ?? Danmaku.DEFAULT_ROW_HEIGHT;\n    this.speed = options.speed ?? Danmaku.DEFAULT_SPEED;\n    this.opacity = options.opacity ?? Danmaku.DEFAULT_OPACITY;\n    this.minGapWidth = options.minGapWidth ?? Danmaku.DEFAULT_GAP_WIDTH;\n\n    this.container.classList.add(Danmaku.containerClassName);\n    this.container.style.position = 'relative';\n    this.container.style.overflow = 'hidden';\n\n    const { width, height } = this.container.getBoundingClientRect();\n    this.width = width;\n    this.height = height;\n    this.trackCount = Math.floor(height / this.rowHeight);\n    if (options.maxRow) {\n      this.trackCount = Math.min(options.maxRow, this.trackCount);\n    }\n    console.log('====trackCount====', this.trackCount);\n    this.trackList = Array(this.trackCount)\n      .fill(null)\n      .map(() => []);\n    console.log('====this.trackList====', this.trackList.length);\n\n    document.addEventListener(\n      'visibilitychange',\n      this.visibilityChangeEventHandle\n    );\n  }\n\n  // 工具方法，数字是否大于0\n  static numberIsGreaterThanZero = (number: number | undefined): boolean => {\n    return number !== undefined && number > 0;\n  };\n\n  // 检查参数是否合法\n  static optionsParamsCheck(options: OptionsType = {}): void {\n    (['rowHeight', 'speed', 'opacity', 'maxRow', 'minGapWidth'] as Array<\n      keyof OptionsType\n    >).forEach((item) => {\n      if (valueIsNotNulish(options[item])) {\n        if (!Danmaku.numberIsGreaterThanZero(options[item])) {\n          throw new Error(`rc-danmaku: ${item} must be greater than 0`);\n        }\n      }\n    });\n  }\n\n  // 页面不可见时暂停弹幕滚动\n  private visibilityChangeEventHandle = (): void => {\n    if (document.visibilityState === 'hidden') {\n      this.isRunningWhenPageHide = !this.allPaused;\n      if (!this.allPaused) {\n        this.pause();\n      }\n    } else if (this.isRunningWhenPageHide && this.allPaused) {\n      this.resume();\n    }\n  };\n\n  // 获取相对最空闲的弹幕轨道\n  private getTrackIndex(): number {\n    if (!this.trackList.length) {\n      return 0;\n    }\n    let result = 0;\n    let minCount = this.trackList[0].length;\n    this.trackList.forEach((list, index) => {\n      const { length } = list.filter((bullet) => !bullet.isTotalOut);\n      if (length < minCount) {\n        minCount = length;\n        result = index;\n      }\n    });\n    return result;\n  }\n\n  /**\n   * 立即发送弹幕到屏幕上，自动寻找最空闲的轨道，若没有空闲轨道则可能有重叠弹幕\n   * @param node 要发送的React组件或者文本\n   */\n  public emit(node: BulletNodeType, options: EmitOptionsType = {}): void {\n    if (!this.container || this.isDestroyed) {\n      return;\n    }\n    const trackIndex = this.getTrackIndex();\n    const bulletItem = new Bullet(node, {\n      color: options.color,\n      speed: this.speed,\n      opacity: this.opacity,\n      targetContainer: this.container,\n      trackIndex,\n      rowHeight: this.rowHeight,\n      minGapWidth: this.minGapWidth,\n      onTotalOut: (): void => {\n        this.popBulletToFreeTrack();\n      },\n      onDestroy: (targetTrackIndex): void => {\n        this.trackList[targetTrackIndex] = this.trackList[\n          targetTrackIndex\n        ].filter((item) => !item.isFinished);\n      },\n    });\n\n    this.trackList[trackIndex].push(bulletItem);\n\n    if (!this.allPaused) {\n      bulletItem.run();\n    }\n  }\n\n  // 是否有空闲轨道（该轨道发送弹幕时不会和上一条弹幕重叠）\n  private hasFreeTrack(): boolean {\n    return this.trackList.some(\n      (bullets) =>\n        !bullets || !bullets.length || bullets[bullets.length - 1].isTotalOut\n    );\n  }\n\n  // 如果队列中还有弹幕并且有空闲的轨道，则弹出\n  private popBulletToFreeTrack(): void {\n    if (this.queue.length > 0 && this.hasFreeTrack()) {\n      console.log('====queue run====');\n      const item = this.queue.shift();\n      if (item) {\n        this.emit(item.node, item.options);\n        this.popBulletToFreeTrack();\n      }\n    }\n  }\n\n  /**\n   * 当有空闲弹幕轨道时，直接发送弹幕，效果通emit方法一样，\n   * 若全部轨道都占用，则将弹幕暂存到队列中，待空闲后再依次放出\n   * @param node\n   */\n  public push(node: BulletNodeType, options: EmitOptionsType = {}): void {\n    if (this.isDestroyed) {\n      return;\n    }\n    if (this.hasFreeTrack()) {\n      this.emit(node, options);\n    } else {\n      this.queue.push({\n        node,\n        options,\n      });\n    }\n  }\n\n  // 推送一个弹幕数组\n  public pushAll(\n    nodeArr: Array<BulletNodeType>,\n    options: EmitOptionsType = {}\n  ): void {\n    if (this.isDestroyed) {\n      return;\n    }\n    this.queue.push(\n      ...nodeArr.map((item) => ({\n        node: item,\n        options,\n      }))\n    );\n    this.popBulletToFreeTrack();\n  }\n\n  /**\n   * pause\n   */\n  public pause(): void {\n    if (this.allPaused) {\n      return;\n    }\n    this.allPaused = true;\n    this.trackList.forEach((list) =>\n      list.forEach((item) => {\n        item.pause();\n      })\n    );\n  }\n\n  /**\n   * resume\n   */\n  public resume(): void {\n    if (!this.allPaused || this.isDestroyed) {\n      return;\n    }\n    this.allPaused = false;\n    this.trackList.forEach((list) =>\n      list.forEach((item) => {\n        item.run();\n      })\n    );\n  }\n\n  /**\n   * destroy\n   */\n  public destroy(): void {\n    if (this.container) {\n      this.trackList.forEach((list) =>\n        list.forEach((item) => {\n          item.destroy();\n        })\n      );\n      this.trackList = [];\n      document.removeEventListener(\n        'visibilitychange',\n        this.visibilityChangeEventHandle\n      );\n      this.container.classList.remove(Danmaku.containerClassName);\n      this.container = null;\n      this.isDestroyed = true;\n    }\n  }\n}\n\nexport default Danmaku;\n","import React, { useEffect, useRef, useState } from 'react';\nimport styled from 'styled-components';\nimport Danmaku from '../../src/index';\n// import Danmaku from 'rc-danmaku';\n\nconst textArr = Array.from(\n  '通过对平面中竖直和水平方向的分析我们将宽泛的弹幕重叠问题收敛为轨道中相邻弹幕两两之间的追及问题最终获得了将候选弹幕挂载到合适轨道中的调度策略'\n);\n\nfunction getRandomIndex(length: number): number {\n  return Math.floor(Math.random() * length);\n}\n\nfunction getRandomText(): string {\n  const length = Math.floor(Math.random() * 19) + 1;\n  return Array(length)\n    .fill(null)\n    .map(() => {\n      return textArr[getRandomIndex(textArr.length)];\n    })\n    .join('');\n}\n\nconst TestDanmaku: React.FC = () => {\n  const danmakuInsRef = useRef<Danmaku | null>(null);\n  const [showColor, setShowColor] = useState(false);\n  const colorRef = useRef('');\n  const [isPaused, setIsPaused] = useState(false);\n\n  useEffect(() => {\n    // 第一个参数是弹幕容器，可以传string类型的选择器，或者直接传dom元素\n    // 第二个object类型的参数是可选参数，包含弹幕配置，里边的所有项均不是必填项\n    const danmakuIns = new Danmaku('.danmaku-wrapper', {\n      rowHeight: 60, // 弹幕轨道高度，默认40（单位px）\n      speed: 120, // 弹幕速度，默认100（单位px/s）\n      opacity: 1, // 弹幕透明度，默认为1，范围 0-1\n      maxRow: 5, // 弹幕最大轨道数，会根据容器高度自动计算，也可以手动赋值\n      minGapWidth: 30, //弹幕之前的最小间隔宽度，默认值20（单位px）\n    });\n    danmakuInsRef.current = danmakuIns;\n  }, []);\n\n  useEffect(() => {\n    if (showColor) {\n      colorRef.current = (document.querySelector(\n        '.color-piker'\n      ) as HTMLInputElement).value;\n    }\n  }, [showColor]);\n\n  useEffect(() => {\n    if (danmakuInsRef.current) {\n      if (isPaused) {\n        danmakuInsRef.current.pause();\n      } else {\n        danmakuInsRef.current.resume();\n      }\n    }\n  }, [isPaused]);\n  return (\n    <Wrapper className=\"test-danmaku\">\n      <div className=\"danmaku-wrapper\" />\n      <div>\n        <span>透明度</span>\n        <input\n          type=\"range\"\n          min=\"0\"\n          max=\"1\"\n          step=\"0.1\"\n          onChange={(e): void => {\n            if (danmakuInsRef.current) {\n              const { value } = e.target;\n              danmakuInsRef.current.opacity = Number(value);\n            }\n          }}\n        />\n      </div>\n      <div>\n        <span>彩色弹幕：</span>\n        <input\n          type=\"checkbox\"\n          onChange={(e): void => {\n            const { checked } = e.target;\n            setShowColor(checked);\n          }}\n        />\n        &nbsp;&nbsp;&nbsp;\n        <input\n          className=\"color-piker\"\n          type=\"color\"\n          defaultValue=\"#ff0000\"\n          style={{\n            visibility: showColor ? 'visible' : 'hidden',\n          }}\n          onChange={(e): void => {\n            const { value } = e.target;\n            colorRef.current = value;\n          }}\n        />\n      </div>\n      <button\n        type=\"button\"\n        onClick={(): void => {\n          if (danmakuInsRef.current) {\n            danmakuInsRef.current.emit(getRandomText(), {\n              color: showColor ? colorRef.current : undefined,\n            });\n          }\n        }}\n      >\n        发送随机文本（过多会重叠）\n      </button>\n      <div>\n        <span>输入文本：</span>\n        <input type=\"text\" className=\"danmaku-text-input\" />\n        <button\n          type=\"button\"\n          onClick={(): void => {\n            if (danmakuInsRef.current) {\n              const $input = document.querySelector(\n                '.danmaku-text-input'\n              ) as HTMLInputElement;\n              if ($input.value && $input.value.trim()) {\n                danmakuInsRef.current.emit($input.value, {\n                  color: showColor ? colorRef.current : undefined,\n                });\n              }\n\n              $input.value = '';\n              $input.focus();\n            }\n          }}\n        >\n          发送\n        </button>\n      </div>\n      <button\n        type=\"button\"\n        onClick={(): void => {\n          if (danmakuInsRef.current) {\n            danmakuInsRef.current.emit(<TestNode>react node</TestNode>);\n          }\n        }}\n      >\n        发送react节点\n      </button>\n      <button\n        type=\"button\"\n        onClick={(): void => {\n          if (danmakuInsRef.current) {\n            danmakuInsRef.current.push(getRandomText(), {\n              color: showColor ? colorRef.current : undefined,\n            });\n          }\n        }}\n      >\n        推送随机文字到发送队列（过多不会重叠，会延迟发送）\n      </button>\n      <button\n        type=\"button\"\n        onClick={(): void => {\n          if (danmakuInsRef.current) {\n            danmakuInsRef.current.push(<TestNode>react node</TestNode>);\n          }\n        }}\n      >\n        推送React节点到发送队列（过多不会重叠，会延迟发送）\n      </button>\n      <button\n        type=\"button\"\n        onClick={(): void => {\n          if (danmakuInsRef.current) {\n            danmakuInsRef.current.pushAll(\n              Array(20)\n                .fill(null)\n                .map(() => getRandomText()),\n              {\n                color: showColor ? colorRef.current : undefined,\n              }\n            );\n          }\n        }}\n      >\n        随机推送20条文字弹幕\n      </button>\n      <button\n        type=\"button\"\n        onClick={(): void => {\n          if (danmakuInsRef.current) {\n            danmakuInsRef.current.pushAll(\n              Array(20)\n                .fill(null)\n                .map(() => <TestNode>react node</TestNode>)\n            );\n          }\n        }}\n      >\n        随机推送20条React节点\n      </button>\n      <div>\n        {isPaused ? (\n          <span style={{ color: 'red' }}>暂停中</span>\n        ) : (\n          <span style={{ color: 'green' }}>运行中</span>\n        )}\n      </div>\n      <div>\n        <button\n          type=\"button\"\n          onClick={(): void => {\n            setIsPaused((p) => !p);\n          }}\n        >\n          {isPaused ? '继续' : '暂停'}\n        </button>\n      </div>\n      <button\n        type=\"button\"\n        onClick={(): void => {\n          if (danmakuInsRef.current) {\n            danmakuInsRef.current.destroy();\n            alert('组件已经被销毁，任何操作将会无相应，重新刷新页面再测吧');\n          }\n        }}\n      >\n        销毁（销毁后无法再发送弹幕）\n      </button>\n    </Wrapper>\n  );\n};\n\nexport default TestDanmaku;\n\nconst Wrapper = styled.div`\n  display: flex;\n  flex-direction: column;\n  justify-content: center;\n  align-items: center;\n  height: 100vh;\n  height: calc(100vh - 45px);\n  input[type='text'] {\n    padding: 0.2em;\n    width: 150px;\n    max-width: 150px;\n  }\n  button {\n    outline: none;\n    appearance: none;\n    padding: 0.2em 1.45em;\n    margin: 0.1em;\n    border: 0.15em solid #cccccc;\n    color: #000000;\n    background-color: #cccccc;\n    &:hover {\n      border-color: #7a7a7a;\n    }\n    &:active {\n      background-color: #999999;\n    }\n  }\n  .danmaku-wrapper {\n    width: 90%;\n    height: 60vw;\n    max-height: 500px;\n    background-color: #000;\n  }\n`;\n\nconst TestNode = styled.div`\n  width: 100px;\n  height: 30px;\n  background: linear-gradient(90deg, pink, red);\n  border-radius: 20px;\n  color: #fff;\n  line-height: 30px;\n  text-align: center;\n`;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport App from './App';\n// import QuickStart from './QuickStart';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n    {/* <QuickStart></QuickStart> */}\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n"],"sourceRoot":""}