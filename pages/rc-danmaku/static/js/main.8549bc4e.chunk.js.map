{"version":3,"sources":["App.tsx","index.tsx"],"names":["textArr","Array","from","getRandomText","length","Math","floor","random","fill","map","getRandomIndex","join","TestDanmaku","danmakuInsRef","useRef","useState","showColor","setShowColor","colorRef","isPaused","setIsPaused","useEffect","danmakuIns","Danmaku","rowHeight","speed","current","document","querySelector","value","pause","resume","Wrapper","className","type","min","max","step","onChange","e","target","opacity","Number","checked","defaultValue","style","visibility","console","log","onClick","emit","color","undefined","$input","trim","focus","TestNode","push","pushAll","p","destroy","alert","styled","div","ReactDOM","render","StrictMode","App","getElementById"],"mappings":"6lCAKA,IAAMA,EAAUC,MAAMC,KACpB,waAOF,SAASC,IACP,IAAMC,EAASC,KAAKC,MAAsB,GAAhBD,KAAKE,UAAiB,EAChD,OAAON,MAAMG,GACVI,KAAK,MACLC,KAAI,WACH,OAAOT,EATb,SAAwBI,GACtB,OAAOC,KAAKC,MAAMD,KAAKE,SAAWH,GAQfM,CAAeV,EAAQI,YAEvCO,KAAK,IAGV,IAoLeC,EApLe,WAC5B,IAAMC,EAAgBC,iBAAuB,MADX,EAEAC,oBAAS,GAFT,mBAE3BC,EAF2B,KAEhBC,EAFgB,KAG5BC,EAAWJ,iBAAO,IAHU,EAIFC,oBAAS,GAJP,mBAI3BI,EAJ2B,KAIjBC,EAJiB,KA+BlC,OAzBAC,qBAAU,WACR,IAAMC,EAAa,IAAIC,IAAQ,mBAAoB,CACjDC,UAAW,GACXC,MAAO,MAETZ,EAAca,QAAUJ,IACvB,IAEHD,qBAAU,WACJL,IACFE,EAASQ,QAAWC,SAASC,cAC3B,gBACqBC,SAExB,CAACb,IAEJK,qBAAU,WACJR,EAAca,UACZP,EACFN,EAAca,QAAQI,QAEtBjB,EAAca,QAAQK,YAGzB,CAACZ,IAEF,eAACa,EAAD,CAASC,UAAU,eAAnB,UACE,qBAAKA,UAAU,oBACf,gCACE,sDACA,uBACEC,KAAK,QACLC,IAAI,IACJC,IAAI,IACJC,KAAK,MACLC,SAAU,SAACC,GACT,GAAI1B,EAAca,QAAS,CAAC,IAClBG,EAAUU,EAAEC,OAAZX,MACRhB,EAAca,QAAQe,QAAUC,OAAOb,UAK/C,gCACE,kEACA,uBACEK,KAAK,WACLI,SAAU,SAACC,GAAa,IACdI,EAAYJ,EAAEC,OAAdG,QACR1B,EAAa0B,MANnB,eAUE,uBACEV,UAAU,cACVC,KAAK,QACLU,aAAa,UACbC,MAAO,CACLC,WAAY9B,EAAY,UAAY,UAEtCsB,SAAU,SAACC,GAAa,IACdV,EAAUU,EAAEC,OAAZX,MACRkB,QAAQC,IAAI,gBAAiBnB,GAC7BX,EAASQ,QAAUG,QAIzB,wBACEK,KAAK,SACLe,QAAS,WACHpC,EAAca,SAChBb,EAAca,QAAQwB,KAAK/C,IAAiB,CAC1CgD,MAAOnC,EAAYE,EAASQ,aAAU0B,KAL9C,4FAYA,gCACE,kEACA,uBAAOlB,KAAK,OAAOD,UAAU,uBAC7B,wBACEC,KAAK,SACLe,QAAS,WACP,GAAIpC,EAAca,QAAS,CACzB,IAAM2B,EAAS1B,SAASC,cACtB,uBAEEyB,EAAOxB,OAASwB,EAAOxB,MAAMyB,QAC/BzC,EAAca,QAAQwB,KAAKG,EAAOxB,MAAO,CACvCsB,MAAOnC,EAAYE,EAASQ,aAAU0B,IAI1CC,EAAOxB,MAAQ,GACfwB,EAAOE,UAdb,6BAqBF,wBACErB,KAAK,SACLe,QAAS,WACHpC,EAAca,SAChBb,EAAca,QAAQwB,KAAK,cAACM,EAAD,2BAJjC,2CAUA,wBACEtB,KAAK,SACLe,QAAS,WACHpC,EAAca,SAChBb,EAAca,QAAQ+B,KAAKtD,IAAiB,CAC1CgD,MAAOnC,EAAYE,EAASQ,aAAU0B,KAL9C,4IAYA,wBACElB,KAAK,SACLe,QAAS,WACHpC,EAAca,SAChBb,EAAca,QAAQgC,QACpBzD,MAAM,IACHO,KAAK,MACLC,KAAI,kBAAMN,OACb,CACEgD,MAAOnC,EAAYE,EAASQ,aAAU0B,KAThD,8CAiBA,8BACGjC,EACC,sBAAM0B,MAAO,CAAEM,MAAO,OAAtB,gCAEA,sBAAMN,MAAO,CAAEM,MAAO,SAAtB,kCAGJ,8BACE,wBACEjB,KAAK,SACLe,QAAS,WACP7B,GAAY,SAACuC,GAAD,OAAQA,MAHxB,SAMGxC,EAAW,eAAO,mBAGvB,wBACEe,KAAK,SACLe,QAAS,WACHpC,EAAca,UAChBb,EAAca,QAAQkC,UACtBC,MAAM,wKALZ,8BAiBA7B,EAAU8B,IAAOC,IAAV,KAkCPP,EAAWM,IAAOC,IAAV,KC3OdC,IAASC,OACP,cAAC,IAAMC,WAAP,UACE,cAACC,EAAD,MAEFxC,SAASyC,eAAe,W","file":"static/js/main.8549bc4e.chunk.js","sourcesContent":["import React, { useEffect, useRef, useState } from 'react';\nimport styled from 'styled-components';\n// import Danmaku from '../../src/index';\nimport Danmaku from 'rc-danmaku';\n\nconst textArr = Array.from(\n  '通过对平面中竖直和水平方向的分析我们将宽泛的弹幕重叠问题收敛为轨道中相邻弹幕两两之间的追及问题最终获得了将候选弹幕挂载到合适轨道中的调度策略'\n);\n\nfunction getRandomIndex(length: number): number {\n  return Math.floor(Math.random() * length);\n}\n\nfunction getRandomText(): string {\n  const length = Math.floor(Math.random() * 19) + 1;\n  return Array(length)\n    .fill(null)\n    .map(() => {\n      return textArr[getRandomIndex(textArr.length)];\n    })\n    .join('');\n}\n\nconst TestDanmaku: React.FC = () => {\n  const danmakuInsRef = useRef<Danmaku | null>(null);\n  const [showColor, setShowColor] = useState(false);\n  const colorRef = useRef('');\n  const [isPaused, setIsPaused] = useState(false);\n\n  useEffect(() => {\n    const danmakuIns = new Danmaku('.danmaku-wrapper', {\n      rowHeight: 40,\n      speed: 120,\n    });\n    danmakuInsRef.current = danmakuIns;\n  }, []);\n\n  useEffect(() => {\n    if (showColor) {\n      colorRef.current = (document.querySelector(\n        '.color-piker'\n      ) as HTMLInputElement).value;\n    }\n  }, [showColor]);\n\n  useEffect(() => {\n    if (danmakuInsRef.current) {\n      if (isPaused) {\n        danmakuInsRef.current.pause();\n      } else {\n        danmakuInsRef.current.resume();\n      }\n    }\n  }, [isPaused]);\n  return (\n    <Wrapper className=\"test-danmaku\">\n      <div className=\"danmaku-wrapper\" />\n      <div>\n        <span>透明度</span>\n        <input\n          type=\"range\"\n          min=\"0\"\n          max=\"1\"\n          step=\"0.1\"\n          onChange={(e): void => {\n            if (danmakuInsRef.current) {\n              const { value } = e.target;\n              danmakuInsRef.current.opacity = Number(value);\n            }\n          }}\n        />\n      </div>\n      <div>\n        <span>彩色弹幕：</span>\n        <input\n          type=\"checkbox\"\n          onChange={(e): void => {\n            const { checked } = e.target;\n            setShowColor(checked);\n          }}\n        />\n        &nbsp;&nbsp;&nbsp;\n        <input\n          className=\"color-piker\"\n          type=\"color\"\n          defaultValue=\"#ff0000\"\n          style={{\n            visibility: showColor ? 'visible' : 'hidden',\n          }}\n          onChange={(e): void => {\n            const { value } = e.target;\n            console.log('====color====', value);\n            colorRef.current = value;\n          }}\n        />\n      </div>\n      <button\n        type=\"button\"\n        onClick={(): void => {\n          if (danmakuInsRef.current) {\n            danmakuInsRef.current.emit(getRandomText(), {\n              color: showColor ? colorRef.current : undefined,\n            });\n          }\n        }}\n      >\n        发送随机文本（过多会重叠）\n      </button>\n      <div>\n        <span>输入文本：</span>\n        <input type=\"text\" className=\"danmaku-text-input\" />\n        <button\n          type=\"button\"\n          onClick={(): void => {\n            if (danmakuInsRef.current) {\n              const $input = document.querySelector(\n                '.danmaku-text-input'\n              ) as HTMLInputElement;\n              if ($input.value && $input.value.trim()) {\n                danmakuInsRef.current.emit($input.value, {\n                  color: showColor ? colorRef.current : undefined,\n                });\n              }\n\n              $input.value = '';\n              $input.focus();\n            }\n          }}\n        >\n          发送\n        </button>\n      </div>\n      <button\n        type=\"button\"\n        onClick={(): void => {\n          if (danmakuInsRef.current) {\n            danmakuInsRef.current.emit(<TestNode>react node</TestNode>);\n          }\n        }}\n      >\n        发送react节点\n      </button>\n      <button\n        type=\"button\"\n        onClick={(): void => {\n          if (danmakuInsRef.current) {\n            danmakuInsRef.current.push(getRandomText(), {\n              color: showColor ? colorRef.current : undefined,\n            });\n          }\n        }}\n      >\n        推送到发送队列（过多不会重叠，会延迟发送）\n      </button>\n      <button\n        type=\"button\"\n        onClick={(): void => {\n          if (danmakuInsRef.current) {\n            danmakuInsRef.current.pushAll(\n              Array(20)\n                .fill(null)\n                .map(() => getRandomText()),\n              {\n                color: showColor ? colorRef.current : undefined,\n              }\n            );\n          }\n        }}\n      >\n        随机推送20条\n      </button>\n      <div>\n        {isPaused ? (\n          <span style={{ color: 'red' }}>暂停中</span>\n        ) : (\n          <span style={{ color: 'green' }}>运行中</span>\n        )}\n      </div>\n      <div>\n        <button\n          type=\"button\"\n          onClick={(): void => {\n            setIsPaused((p) => !p);\n          }}\n        >\n          {isPaused ? '继续' : '暂停'}\n        </button>\n      </div>\n      <button\n        type=\"button\"\n        onClick={(): void => {\n          if (danmakuInsRef.current) {\n            danmakuInsRef.current.destroy();\n            alert('组件已经被销毁，任何操作将会无相应，重新刷新页面再测吧');\n          }\n        }}\n      >\n        销毁\n      </button>\n    </Wrapper>\n  );\n};\n\nexport default TestDanmaku;\n\nconst Wrapper = styled.div`\n  display: flex;\n  flex-direction: column;\n  justify-content: center;\n  align-items: center;\n  height: 100vh;\n  input[type='text'] {\n    padding: 0.2em;\n    width: 150px;\n    max-width: 150px;\n  }\n  button {\n    outline: none;\n    appearance: none;\n    padding: 0.2em 1.45em;\n    margin: 0.1em;\n    border: 0.15em solid #cccccc;\n    color: #000000;\n    background-color: #cccccc;\n    &:hover {\n      border-color: #7a7a7a;\n    }\n    &:active {\n      background-color: #999999;\n    }\n  }\n  .danmaku-wrapper {\n    width: 90%;\n    height: 70vw;\n    max-height: 600px;\n    background-color: #000;\n  }\n`;\n\nconst TestNode = styled.div`\n  width: 100px;\n  height: 30px;\n  background: linear-gradient(90deg, pink, red);\n  border-radius: 20px;\n  color: #fff;\n  line-height: 30px;\n  text-align: center;\n`;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport App from './App';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n"],"sourceRoot":""}