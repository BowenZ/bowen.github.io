{"version":3,"sources":["../../src/Bullet.tsx","../../src/Danmaku.tsx","App.tsx","index.tsx"],"names":["BulletStatus","Bullet","node","options","status","PENDING","element","speed","targetContainer","trackIndex","rowHeight","onTotalOut","isTotalOut","rightDistance","totalOutTimer","this","div","document","createElement","className","setAttribute","style","opacity","String","reactNode","textShadow","color","fontSize","ReactDOM","render","appendChild","width","getBoundingClientRect","left","top","minGapWidth","paddingRight","addEventListener","destroy","FINISHED","onDestroy","bulletLeft","notOutWidth","offsetWidth","totalOutTime","setTimeout","clearTimeout","transition","scrollWidth","toFixed","transform","RUNNING","startTotalOutTimer","containerLeft","containeWidth","PAUSED","clearTotalOutTimer","unmountComponentAtNode","remove","Danmaku","ele","container","height","trackCount","allPaused","isDestroyed","trackList","queue","isRunningWhenPageHide","visibilityChangeEventHandle","visibilityState","pause","resume","optionsParamsCheck","querySelector","Error","DEFAULT_ROW_HEIGHT","DEFAULT_SPEED","DEFAULT_OPACITY","DEFAULT_GAP_WIDTH","classList","add","containerClassName","position","overflow","Math","floor","maxRow","min","Array","fill","map","length","result","minCount","forEach","list","index","filter","bullet","getTrackIndex","bulletItem","popBulletToFreeTrack","targetTrackIndex","item","isFinished","onBulletOut","push","run","onBulletIn","getRestAmount","onQueueRunOut","some","bullets","hasFreeTrack","shift","emit","nodeArr","removeEventListener","numberIsGreaterThanZero","number","undefined","hotText","getRandomText","random","TestDanmaku","danmakuInsRef","useRef","useState","showColor","setShowColor","colorRef","isPaused","setIsPaused","useEffect","danmakuIns","current","value","Wrapper","type","max","step","onChange","e","target","Number","checked","defaultValue","visibility","onClick","$input","trim","focus","TestNode","pushAll","clearQueue","p","alert","styled","StrictMode","App","getElementById"],"mappings":"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","file":"static/js/main.a8202fd2.chunk.js","sourcesContent":["import React from 'react';\nimport ReactDOM from 'react-dom';\n\nenum BulletStatus {\n  // 等待中\n  PENDING = 'pending',\n  // 运行中\n  RUNNING = 'running',\n  // 暂停中\n  PAUSED = 'paused',\n  // 已完成\n  FINISHED = 'finished',\n}\n\nclass Bullet {\n  // 当前状态\n  status: BulletStatus = BulletStatus.PENDING;\n\n  // 弹幕DOM元素\n  element: HTMLElement;\n\n  // 速度\n  speed: number;\n\n  // 目标挂载容器\n  targetContainer: HTMLElement;\n\n  // 目标轨道\n  trackIndex: number;\n\n  // 弹幕行高\n  rowHeight: number;\n\n  // 弹幕完全显示的回调\n  onTotalOut: ((trackIndex: number) => void) | undefined;\n\n  // 是否全部出现\n  public isTotalOut = false;\n\n  // 暂停时距离右边的距离\n  private rightDistance = 0;\n\n  // 弹幕全部出现的计时器\n  private totalOutTimer = 0;\n\n  constructor(\n    node: React.ReactElement | string,\n    options: {\n      color?: string;\n      speed: number;\n      opacity: number;\n      targetContainer: HTMLElement;\n      trackIndex: number;\n      rowHeight: number;\n      minGapWidth?: number;\n      onTotalOut?: (trackIndex: number) => void;\n      onDestroy(trackIndex: number): void;\n    }\n  ) {\n    this.speed = options.speed;\n    this.targetContainer = options.targetContainer;\n    this.trackIndex = options.trackIndex;\n    this.rowHeight = options.rowHeight;\n    this.onTotalOut = options.onTotalOut;\n    const div = document.createElement('div');\n    div.className = 'bullet-item';\n    div.setAttribute(\n      'style',\n      `position: absolute;\n       line-height: 1.125;\n       user-select: none;\n       white-space: pre;\n       perspective: 500px;\n       will-change: transform;\n       pointer-events: none;`\n    );\n    div.style.opacity = String(options.opacity);\n\n    const reactNode =\n      typeof node === 'string' ? (\n        <span\n          className=\"bullet-item-text\"\n          style={{\n            textShadow:\n              '#000 1px 0px 1px, #000 0px 1px 1px, #000 0px -1px 1px,#000 -1px 0px 1px',\n            color: options.color || '#fff',\n            fontSize: '25px',\n          }}\n        >\n          {node}\n        </span>\n      ) : (\n        node\n      );\n\n    ReactDOM.render(reactNode, div);\n\n    this.element = div;\n\n    options.targetContainer.appendChild(this.element);\n\n    const { width } = this.targetContainer.getBoundingClientRect();\n    div.style.left = `${width}px`;\n    div.style.top = `${this.trackIndex * this.rowHeight}px`;\n    if (options.minGapWidth && options.minGapWidth > 0) {\n      div.style.paddingRight = `${options.minGapWidth}px`;\n    }\n\n    this.element.addEventListener('transitionend', () => {\n      // console.log('====transition end====');\n      this.destroy();\n      this.status = BulletStatus.FINISHED;\n      this.isTotalOut = false;\n      options.onDestroy(options.trackIndex);\n    });\n  }\n\n  // 根据弹幕当前位置计算出弹幕完全显示需要的时间，并在改时间后将弹幕状态设置为完全可见状态\n  private startTotalOutTimer(): void {\n    if (this.totalOutTimer) {\n      return;\n    }\n    const { left, width } = this.targetContainer.getBoundingClientRect();\n    const { left: bulletLeft } = this.element.getBoundingClientRect();\n    const notOutWidth = this.element.offsetWidth - (left + width - bulletLeft);\n\n    if (notOutWidth <= 0) {\n      return;\n    }\n\n    // 该条弹幕完全展示出所需的时间\n    const totalOutTime = notOutWidth / this.speed;\n\n    this.totalOutTimer = setTimeout(() => {\n      // console.log('====set is total out====');\n      this.isTotalOut = true;\n      this.totalOutTimer = 0;\n      if (this.onTotalOut) {\n        this.onTotalOut(this.trackIndex);\n      }\n    }, totalOutTime * 1000);\n  }\n\n  // 清楚弹幕完全显示状态的计时器\n  private clearTotalOutTimer(): void {\n    if (this.totalOutTimer) {\n      clearTimeout(this.totalOutTimer);\n      this.totalOutTimer = 0;\n    }\n  }\n\n  // 弹幕运行\n  public run(): void {\n    const { width } = this.targetContainer.getBoundingClientRect();\n    this.element.style.transition = `transform ${(\n      (width + this.element.scrollWidth - this.rightDistance) /\n      this.speed\n    ).toFixed(2)}s linear`;\n    this.element.style.transform = `translate3d(-${\n      width + this.element.scrollWidth\n    }px, 0, 0)`;\n    this.status = BulletStatus.RUNNING;\n    this.startTotalOutTimer();\n  }\n\n  // 弹幕暂停\n  public pause(): void {\n    const {\n      left: containerLeft,\n      width: containeWidth,\n    } = this.targetContainer.getBoundingClientRect();\n    const { left: bulletLeft } = this.element.getBoundingClientRect();\n    this.rightDistance = containeWidth - (bulletLeft - containerLeft);\n    this.element.style.transform = `translate3d(-${this.rightDistance}px, 0, 0)`;\n    this.element.style.transition = 'transform 0s linear 0s';\n    this.status = BulletStatus.PAUSED;\n    this.clearTotalOutTimer();\n  }\n\n  // 销毁弹幕\n  public destroy(): void {\n    if (this.totalOutTimer) {\n      clearTimeout(this.totalOutTimer);\n    }\n    ReactDOM.unmountComponentAtNode(this.element);\n    this.element.remove();\n  }\n\n  public get isRunning(): boolean {\n    return this.status === BulletStatus.RUNNING;\n  }\n\n  public get isFinished(): boolean {\n    return this.status === BulletStatus.FINISHED;\n  }\n}\n\nexport default Bullet;\n","import React from 'react';\nimport Bullet from './Bullet';\n\ntype BulletNodeType = React.ReactElement | string;\n\ntype OptionsType = {\n  // 弹幕轨道高度\n  rowHeight?: number;\n  // 弹幕速度\n  speed?: number;\n  // 弹幕初始透明度\n  opacity?: number;\n  // 弹幕最大轨道数\n  maxRow?: number;\n  // 弹幕之前的最小间隔宽度\n  minGapWidth?: number;\n  // 弹幕入场回调\n  onBulletIn?: () => void;\n  // 弹幕出场回调\n  onBulletOut?: () => void;\n  // 队列中的弹幕全部已经发出的回调\n  onQueueRunOut?: () => void;\n};\n\ntype EmitOptionsType = {\n  color?: string;\n};\n\nclass Danmaku {\n  static DEFAULT_ROW_HEIGHT = 40;\n\n  static DEFAULT_SPEED = 100;\n\n  static DEFAULT_OPACITY = 1;\n\n  static DEFAULT_GAP_WIDTH = 20;\n\n  // 弹幕容器\n  private container: HTMLElement | null = null;\n\n  // 容器宽度\n  width = 0;\n\n  // 容器高度\n  height = 0;\n\n  // 弹幕轨道高度\n  rowHeight = 40;\n\n  // 弹幕轨道数量\n  trackCount = 0;\n\n  // 弹幕速度\n  speed = 100;\n\n  // 弹幕透明度 0-1\n  opacity = 1;\n\n  // 弹幕之前的最小间隔宽度\n  minGapWidth = 0;\n\n  // 是否处于暂停中\n  allPaused = false;\n\n  // 是否已被销毁\n  isDestroyed = false;\n\n  private options: OptionsType | Record<string, never> = {};\n\n  // 当前展示的弹幕数组\n  private trackList: Array<Array<Bullet>> = [];\n\n  // 待发送的弹幕队列\n  private queue: Array<{\n    node: BulletNodeType;\n    options?: EmitOptionsType;\n  }> = [];\n\n  private isRunningWhenPageHide = true;\n\n  static containerClassName = 'danmaku-container';\n\n  constructor(ele: string | HTMLElement, options: OptionsType = {}) {\n    Danmaku.optionsParamsCheck(options);\n    if (typeof ele === 'string') {\n      this.container = document.querySelector(ele);\n      if (!this.container) {\n        throw new Error('container not found');\n      }\n    } else {\n      this.container = ele;\n    }\n    this.options = options;\n    this.rowHeight = options.rowHeight ?? Danmaku.DEFAULT_ROW_HEIGHT;\n    this.speed = options.speed ?? Danmaku.DEFAULT_SPEED;\n    this.opacity = options.opacity ?? Danmaku.DEFAULT_OPACITY;\n    this.minGapWidth = options.minGapWidth ?? Danmaku.DEFAULT_GAP_WIDTH;\n\n    this.container.classList.add(Danmaku.containerClassName);\n    this.container.style.position = 'relative';\n    this.container.style.overflow = 'hidden';\n\n    const { width, height } = this.container.getBoundingClientRect();\n    this.width = width;\n    this.height = height;\n    this.trackCount = Math.floor(height / this.rowHeight);\n    if (options.maxRow && options.maxRow > 0) {\n      this.trackCount = Math.min(options.maxRow, this.trackCount);\n    }\n    console.log('====trackCount====', this.trackCount);\n    this.trackList = Array(this.trackCount)\n      .fill(null)\n      .map(() => []);\n    console.log('====this.trackList====', this.trackList.length);\n\n    document.addEventListener(\n      'visibilitychange',\n      this.visibilityChangeEventHandle\n    );\n  }\n\n  // 工具方法，数字是否大于0\n  static numberIsGreaterThanZero = (number: number | undefined): boolean => {\n    return number !== undefined && number >= 0;\n  };\n\n  // 检查参数是否合法\n  static optionsParamsCheck(options: OptionsType = {}): void {\n    (['rowHeight', 'speed', 'opacity', 'maxRow', 'minGapWidth'] as Array<\n      keyof OptionsType\n    >).forEach((item) => {\n      if (\n        typeof options[item] === 'number' &&\n        !Danmaku.numberIsGreaterThanZero(options[item] as number)\n      ) {\n        throw new Error(`rc-danmaku: ${item} 必须大于等于0`);\n      }\n    });\n  }\n\n  // 页面不可见时暂停弹幕滚动\n  private visibilityChangeEventHandle = (): void => {\n    if (document.visibilityState === 'hidden') {\n      this.isRunningWhenPageHide = !this.allPaused;\n      if (!this.allPaused) {\n        this.pause();\n      }\n    } else if (this.isRunningWhenPageHide && this.allPaused) {\n      this.resume();\n    }\n  };\n\n  // 获取相对最空闲的弹幕轨道\n  private getTrackIndex(): number {\n    if (!this.trackList.length) {\n      return 0;\n    }\n    let result = 0;\n    let minCount = this.trackList[0].length;\n    this.trackList.forEach((list, index) => {\n      const { length } = list.filter((bullet) => !bullet.isTotalOut);\n      if (length < minCount) {\n        minCount = length;\n        result = index;\n      }\n    });\n    return result;\n  }\n\n  /**\n   * 立即发送弹幕到屏幕上，自动寻找最空闲的轨道，若没有空闲轨道则可能有重叠弹幕\n   * @param node 要发送的React组件或者文本\n   */\n  public emit(node: BulletNodeType, options: EmitOptionsType = {}): void {\n    if (!this.container || this.isDestroyed) {\n      return;\n    }\n    const trackIndex = this.getTrackIndex();\n    const bulletItem = new Bullet(node, {\n      color: options.color,\n      speed: this.speed,\n      opacity: this.opacity,\n      targetContainer: this.container,\n      trackIndex,\n      rowHeight: this.rowHeight,\n      minGapWidth: this.minGapWidth,\n      onTotalOut: (): void => {\n        this.popBulletToFreeTrack();\n      },\n      onDestroy: (targetTrackIndex): void => {\n        this.trackList[targetTrackIndex] = this.trackList[\n          targetTrackIndex\n        ].filter((item) => !item.isFinished);\n        this.options.onBulletOut?.();\n      },\n    });\n\n    this.trackList[trackIndex].push(bulletItem);\n\n    if (!this.allPaused) {\n      bulletItem.run();\n      this.options.onBulletIn?.();\n    }\n\n    if (this.getRestAmount() === 0) {\n      this.options.onQueueRunOut?.();\n    }\n  }\n\n  // 是否有空闲轨道（该轨道发送弹幕时不会和上一条弹幕重叠）\n  private hasFreeTrack(): boolean {\n    return this.trackList.some(\n      (bullets) =>\n        !bullets || !bullets.length || bullets[bullets.length - 1].isTotalOut\n    );\n  }\n\n  // 如果队列中还有弹幕并且有空闲的轨道，则弹出\n  private popBulletToFreeTrack(): void {\n    if (this.queue.length > 0 && this.hasFreeTrack()) {\n      console.log('====queue run====');\n      const item = this.queue.shift();\n      if (item) {\n        this.emit(item.node, item.options);\n        this.popBulletToFreeTrack();\n      }\n    }\n  }\n\n  /**\n   * 当有空闲弹幕轨道时，直接发送弹幕，效果通emit方法一样，\n   * 若全部轨道都占用，则将弹幕暂存到队列中，待空闲后再依次放出\n   * @param node\n   */\n  public push(node: BulletNodeType, options: EmitOptionsType = {}): void {\n    if (this.isDestroyed) {\n      return;\n    }\n    if (this.hasFreeTrack()) {\n      this.emit(node, options);\n    } else {\n      this.queue.push({\n        node,\n        options,\n      });\n    }\n  }\n\n  // 推送一个弹幕数组\n  public pushAll(\n    nodeArr: Array<BulletNodeType>,\n    options: EmitOptionsType = {}\n  ): void {\n    if (this.isDestroyed) {\n      return;\n    }\n    this.queue.push(\n      ...nodeArr.map((item) => ({\n        node: item,\n        options,\n      }))\n    );\n    this.popBulletToFreeTrack();\n  }\n\n  /**\n   * pause\n   */\n  public pause(): void {\n    if (this.allPaused) {\n      return;\n    }\n    this.allPaused = true;\n    this.trackList.forEach((list) =>\n      list.forEach((item) => {\n        item.pause();\n      })\n    );\n  }\n\n  /**\n   * resume\n   */\n  public resume(): void {\n    if (!this.allPaused || this.isDestroyed) {\n      return;\n    }\n    this.allPaused = false;\n    this.trackList.forEach((list) =>\n      list.forEach((item) => {\n        item.run();\n      })\n    );\n  }\n\n  /**\n   * destroy\n   */\n  public destroy(): void {\n    if (this.container) {\n      this.trackList.forEach((list) =>\n        list.forEach((item) => {\n          item.destroy();\n        })\n      );\n      this.trackList = [];\n      document.removeEventListener(\n        'visibilitychange',\n        this.visibilityChangeEventHandle\n      );\n      this.container.classList.remove(Danmaku.containerClassName);\n      this.container = null;\n      this.isDestroyed = true;\n    }\n  }\n\n  /**\n   * 获取剩余还没发出的弹幕数量\n   */\n  public getRestAmount(): number {\n    return this.queue.length;\n  }\n\n  /**\n   * 清空弹幕队列（只能清空排队中还未发出的弹幕）\n   */\n  public clearQueue(): void {\n    this.queue = [];\n  }\n}\n\nexport default Danmaku;\n","import React, { useEffect, useRef, useState } from 'react';\nimport styled from 'styled-components';\nimport Danmaku from '../../src/index';\n// import Danmaku from 'rc-danmaku';\n\n// const textArr = Array.from(\n//   '通过对平面中竖直和水平方向的分析我们将宽泛的弹幕重叠问题收敛为轨道中相邻弹幕两两之间的追及问题最终获得了将候选弹幕挂载到合适轨道中的调度策略'\n// );\n\nfunction getRandomIndex(length: number): number {\n  return Math.floor(Math.random() * length);\n}\n\nconst hotText = [\n  '真实',\n  '前方高能',\n  '颜表立',\n  '弹幕护体',\n  '合影',\n  '开口跪',\n  '真香',\n  '战歌起',\n  '空降成功',\n  '多谢款待',\n  '有内味了',\n  '双厨狂喜',\n  '禁止套娃',\n  'AWSL',\n  '由来只有新人笑，有谁听到旧人哭',\n  '纵有创伤不退避，梦想有日达成，找到心底梦想的世界，终可见',\n  '我曾赋诗写字偷得浮生半日闲 亦曾宴饮群士笑那繁华皆浮云',\n  '做你喜欢做的那是自由，喜欢你所做的那是快乐',\n  '当我们凶狠地对待这个世界时，这个世界突然变得温文尔雅了',\n  '我的钱包就像个洋葱，每次打开都叫我泪流满面',\n  '世界上最遥远的距离不是生与死，而是星期一的上午到星期五的下午',\n  '都说字如其人。我看了病历本。都不敢想象医生的样子了',\n  '如果菜咸了，就放一会，因为时间可以冲淡一切',\n  '你这种整天什么都不干，就知道吃喝玩乐，连门都不肯出的生活，跟活在天堂有什么区别',\n  '有时候晚上探望冰箱一下，就是就是想知道它过得好不好。',\n  '孔雀开屏都是雄性，所以献媚不一定都是女人。',\n  '长得高有什么用？上吊还不是要踩凳子。',\n  '有人考试靠实力，有人考试靠视力，尼玛我考试靠想象力。',\n  '不怕虎一样的敌人，就怕猪一样的队友。',\n  '凡是用钱可以解决的问题，我现在都解决不了。',\n  '人就是这么奇怪，嫌旧手机旧衣服嫌旧车子旧房子，就是不嫌自己旧。',\n  '从前有根火柴，他感觉头有点痒就挠啊挠，结果把自己烧死了。',\n  '我看上去好孤单啊，连个偏旁部首都没有。',\n  '醒醒！你该吃安眠药了！',\n  '我借了朋友十万块，他用来做整容手术了！现在我的钱打水漂了...',\n  '我的朋友真自私！他关心自己甚于关心我！',\n  '傻孩子! 你怎么会是傻孩子呢？',\n  '没有到会的同志麻烦举一下手！',\n  '小时候家里穷，洗不起澡，只能站在窗户外面看别人洗澡',\n  '“海绵宝宝你被开除了” “蟹老板” “不用谢”',\n  '我从未见过如此厚颜无耻之人',\n  '肥宅用的香皂叫做肥皂。',\n  '当你可以说出妈妈再也不用担心我的学习的时候，也差不多是该被催婚的时候了。',\n  '遇到火灾一定要用湿毛巾捂住口鼻，如果没有湿毛巾可以用吓尿了的胖次代替。',\n  '人不要害怕失败，有时你只需要再多坚持一下，就能化失败为惨败。',\n  '优秀的作品叫神作，劣质的作品叫粪作，不让播的作品叫臭作。',\n  '努力不一定会成功，但可以用来安慰失败的自己。',\n  '次时代就是质次价高的时代。',\n  '你永远无法叫醒装睡的人，你也永远无法让装逼的人清醒。',\n  '每年的一月四月七月十月被称为换老婆月。',\n  '工作岗位的不同决定了工作借口的不同。',\n  '天台上，刘德华对梁朝伟说给我个机会，我想做个好人。梁朝伟说你是个好人。可见两个人的恋情结束了。',\n  '祝愿天下的键盘侠买人身保险家属都能获得理赔。',\n  '我在拼多多上买了个老婆，快递送来个老婆儿。',\n  '做手机和做安全套是一样的，都追求超薄。',\n  '吃薯片本身不会长胖，又吃薯片又呼吸才会，所以只要吃薯片的时候屏住呼吸就不会胖了。',\n  '解决失眠问题，找中学老师比找医生管用。',\n  '太空杯是飞机杯的升级版。',\n  '上班族会花费大量的精力用来假装自己上班很认真。',\n  '钱不是大风刮来的，你只有通过辛勤劳动，才能为你的老板创造财富。',\n  '丰胸最科学的办法是用放大镜。',\n  '拼多多的出现让我感觉那些年我们对淘宝太严格了。',\n  '你无法用打发要饭的钱打发要饭的。',\n  '不要和专业写段子的人聊天，否则你前半生的人生经历会变成他后半生的人生财富。',\n  '吾日三省吾身翻译成现代汉语就是“我日啊，居然让我一天反省三次”。',\n  '《山路十八弯》是电影《头文字D》的主题曲。',\n  '黑人朋友最喜欢的中国诗人是李白，上次我问黑人他怎么这么黑，他回答我说：“就李白”。',\n  '赌博和理财的区别在于，赌博是钱是你的，有人引导你把钱给别人；理财是你已经把钱给了别人，但有人引导你相信钱还是你的。',\n  '你不是因为想拉屎才蹲下，而是因为蹲下了所以想要顺便拉个屎，这叫屁股决定脑袋。',\n  '清明节是给现实中已经不存在的人烧假钞，手游是给现实中不存在的人烧真钞。',\n  '会变身的键盘叫做机械键盘。',\n];\n\n// function getRandomText(): string {\n//   const length = Math.floor(Math.random() * 19) + 1;\n//   return Array(length)\n//     .fill(null)\n//     .map(() => {\n//       return textArr[getRandomIndex(textArr.length)];\n//     })\n//     .join('');\n// }\n\nfunction getRandomText(): string {\n  return hotText[getRandomIndex(hotText.length)];\n}\n\nconst TestDanmaku: React.FC = () => {\n  const danmakuInsRef = useRef<Danmaku | null>(null);\n  const [showColor, setShowColor] = useState(false);\n  const colorRef = useRef('');\n  const [isPaused, setIsPaused] = useState(false);\n\n  useEffect(() => {\n    // 第一个参数是弹幕容器，可以传string类型的选择器，或者直接传dom元素\n    // 第二个object类型的参数是可选参数，包含弹幕配置，里边的所有项均不是必填项\n    const danmakuIns = new Danmaku('.danmaku-wrapper', {\n      rowHeight: 60, // 弹幕轨道高度，默认40（单位px）\n      speed: 120, // 弹幕速度，默认100（单位px/s）\n      opacity: 1, // 弹幕透明度，默认为1，范围 0-1\n      // maxRow: 3, // 弹幕最大轨道数，会根据容器高度自动计算，也可以手动赋值（此处设为0表示使用自动计算高度）\n      minGapWidth: 30, //弹幕之前的最小间隔宽度，默认值20（单位px）\n      // 每个弹幕进入时触发\n      onBulletIn() {\n        console.log('====bullet in====', danmakuIns.getRestAmount());\n        // if (danmakuIns.getRestAmount() < 1) {\n        //   danmakuIns.pushAll(['asdasd', 'qweqwe', 'zxczxc']);\n        // }\n      },\n      // 每个弹幕消失时触发\n      onBulletOut() {\n        console.log('====bullet out====', danmakuIns.getRestAmount());\n      },\n      // 队列中的弹幕发送完时触发（每次发送弹幕都会检查，不管用何种方式发送，手动清空队列不会触发该事件）\n      onQueueRunOut() {\n        console.log('====queue run out====');\n        // danmakuIns.pushAll(['123','456'])\n      },\n    });\n\n    danmakuInsRef.current = danmakuIns;\n  }, []);\n\n  useEffect(() => {\n    if (showColor) {\n      colorRef.current = (document.querySelector(\n        '.color-piker'\n      ) as HTMLInputElement).value;\n    }\n  }, [showColor]);\n\n  useEffect(() => {\n    if (danmakuInsRef.current) {\n      if (isPaused) {\n        danmakuInsRef.current.pause();\n      } else {\n        danmakuInsRef.current.resume();\n      }\n    }\n  }, [isPaused]);\n  return (\n    <Wrapper className=\"test-danmaku\">\n      <div className=\"danmaku-wrapper\" />\n      <div>\n        <small>弹幕文字来源于网络随机抓取内容</small>\n      </div>\n      <div>\n        <span>透明度</span>\n        <input\n          type=\"range\"\n          min=\"0\"\n          max=\"1\"\n          step=\"0.1\"\n          onChange={(e): void => {\n            if (danmakuInsRef.current) {\n              const { value } = e.target;\n              danmakuInsRef.current.opacity = Number(value);\n            }\n          }}\n        />\n      </div>\n      <div>\n        <span>彩色弹幕：</span>\n        <input\n          type=\"checkbox\"\n          onChange={(e): void => {\n            const { checked } = e.target;\n            setShowColor(checked);\n          }}\n        />\n        &nbsp;&nbsp;&nbsp;\n        <input\n          className=\"color-piker\"\n          type=\"color\"\n          defaultValue=\"#ff0000\"\n          style={{\n            visibility: showColor ? 'visible' : 'hidden',\n          }}\n          onChange={(e): void => {\n            const { value } = e.target;\n            colorRef.current = value;\n          }}\n        />\n      </div>\n\n      <div>\n        <span>输入文本：</span>\n        <input type=\"text\" className=\"danmaku-text-input\" />\n        <button\n          type=\"button\"\n          onClick={(): void => {\n            if (danmakuInsRef.current) {\n              const $input = document.querySelector(\n                '.danmaku-text-input'\n              ) as HTMLInputElement;\n              if ($input.value && $input.value.trim()) {\n                danmakuInsRef.current.emit($input.value, {\n                  color: showColor ? colorRef.current : undefined,\n                });\n              }\n\n              $input.value = '';\n              $input.focus();\n            }\n          }}\n        >\n          立即发送\n        </button>\n      </div>\n\n      <button\n        type=\"button\"\n        onClick={(): void => {\n          if (danmakuInsRef.current) {\n            danmakuInsRef.current.push(getRandomText(), {\n              color: showColor ? colorRef.current : undefined,\n            });\n          }\n        }}\n      >\n        推送随机文字到发送队列（过多不会重叠，会延迟发送）\n      </button>\n      <button\n        type=\"button\"\n        onClick={(): void => {\n          if (danmakuInsRef.current) {\n            danmakuInsRef.current.push(<TestNode>react node</TestNode>);\n          }\n        }}\n      >\n        推送React节点到发送队列（过多不会重叠，会延迟发送）\n      </button>\n      <button\n        type=\"button\"\n        onClick={(): void => {\n          if (danmakuInsRef.current) {\n            danmakuInsRef.current.pushAll(\n              Array(20)\n                .fill(null)\n                .map(() => getRandomText()),\n              {\n                color: showColor ? colorRef.current : undefined,\n              }\n            );\n          }\n        }}\n      >\n        随机推送20条文字弹幕\n      </button>\n      <button\n        type=\"button\"\n        onClick={(): void => {\n          if (danmakuInsRef.current) {\n            danmakuInsRef.current.pushAll(\n              Array(20)\n                .fill(null)\n                .map(() => <TestNode>react node</TestNode>)\n            );\n          }\n        }}\n      >\n        随机推送20条React节点\n      </button>\n      <button\n        type=\"button\"\n        onClick={(): void => {\n          if (danmakuInsRef.current) {\n            danmakuInsRef.current.emit(getRandomText(), {\n              color: showColor ? colorRef.current : undefined,\n            });\n          }\n        }}\n      >\n        立即发送随机文本（自动寻找空闲轨道，过多会重叠）\n      </button>\n      <button\n        type=\"button\"\n        onClick={(): void => {\n          if (danmakuInsRef.current) {\n            danmakuInsRef.current.emit(<TestNode>react node</TestNode>);\n          }\n        }}\n      >\n        立即发送react节点（自动寻找空闲轨道，过多会重叠）\n      </button>\n      <button\n        type=\"button\"\n        onClick={(): void => {\n          if (danmakuInsRef.current) {\n            danmakuInsRef.current.clearQueue();\n          }\n        }}\n      >\n        清空排队中的弹幕队列（已发送的不会被清，不会触发onQueueRunOut事件）\n      </button>\n      <div>\n        {isPaused ? (\n          <span style={{ color: 'red' }}>暂停中</span>\n        ) : (\n          <span style={{ color: 'green' }}>运行中</span>\n        )}\n      </div>\n      <div>\n        <button\n          type=\"button\"\n          onClick={(): void => {\n            setIsPaused((p) => !p);\n          }}\n        >\n          {isPaused ? '继续' : '暂停'}\n        </button>\n      </div>\n      <button\n        type=\"button\"\n        onClick={(): void => {\n          if (danmakuInsRef.current) {\n            danmakuInsRef.current.destroy();\n            alert('组件已经被销毁，任何操作将会无相应，重新刷新页面再测吧');\n          }\n        }}\n      >\n        销毁（销毁后无法再发送弹幕）\n      </button>\n    </Wrapper>\n  );\n};\n\nexport default TestDanmaku;\n\nconst Wrapper = styled.div`\n  display: flex;\n  flex-direction: column;\n  justify-content: center;\n  align-items: center;\n  height: 100vh;\n  height: calc(100vh - 45px);\n  input[type='text'] {\n    padding: 0.2em;\n    width: 150px;\n    max-width: 150px;\n  }\n  button {\n    outline: none;\n    appearance: none;\n    padding: 0.2em 1.45em;\n    margin: 0.1em;\n    border: 0.15em solid #cccccc;\n    color: #000000;\n    background-color: #cccccc;\n    &:hover {\n      border-color: #7a7a7a;\n    }\n    &:active {\n      background-color: #999999;\n    }\n  }\n  .danmaku-wrapper {\n    width: 90%;\n    height: 60vw;\n    max-height: 500px;\n    background-color: #000;\n  }\n`;\n\nconst TestNode = styled.div`\n  width: 100px;\n  height: 30px;\n  background: linear-gradient(90deg, pink, red);\n  border-radius: 20px;\n  color: #fff;\n  line-height: 30px;\n  text-align: center;\n`;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport App from './App';\n// import QuickStart from './QuickStart';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n    {/* <QuickStart></QuickStart> */}\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n"],"sourceRoot":""}